name: Create Release

on:
  workflow_dispatch:
    inputs:
      release-type:
        description: 'Release type (auto-detect based on commits, or override)'
        required: false
        type: choice
        default: 'auto'
        options:
          - auto
          - patch
          - minor
          - major

permissions:
  contents: write
  pull-requests: write

jobs:
  create-release-pr:
    name: Create Release PR
    runs-on: ubuntu-latest
    # Only allow running from develop branch
    if: github.ref == 'refs/heads/develop'

    steps:
      - name: Checkout code
        uses: actions/checkout@v6
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up Python
        uses: actions/setup-python@v6
        with:
          python-version: '3.12'

      - name: Install python-semantic-release
        run: |
          python -m pip install --upgrade pip
          pip install python-semantic-release

      - name: Configure Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Determine next version
        id: version
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Get the next version based on conventional commits
          if [ "${{ github.event.inputs.release-type }}" == "auto" ]; then
            NEXT_VERSION=$(semantic-release version --print 2>/dev/null || echo "")
          else
            # Manual override: patch, minor, or major
            NEXT_VERSION=$(semantic-release version --print --${{ github.event.inputs.release-type }} 2>/dev/null || echo "")
          fi

          if [ -z "$NEXT_VERSION" ]; then
            echo "âŒ No new version to release. No relevant commits since last release."
            echo "release_needed=false" >> $GITHUB_OUTPUT
          else
            echo "next_version=${NEXT_VERSION}" >> $GITHUB_OUTPUT
            echo "release_needed=true" >> $GITHUB_OUTPUT
            echo "âœ… Next version will be: ${NEXT_VERSION}"
          fi

      - name: Create release branch and commit
        if: steps.version.outputs.release_needed == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          VERSION=${{ steps.version.outputs.next_version }}
          BRANCH="release/${VERSION}"

          # Clean up any existing release branch
          git branch -D "${BRANCH}" 2>/dev/null || true
          if git ls-remote --heads origin "${BRANCH}" | grep -q "${BRANCH}"; then
            git push origin --delete "${BRANCH}" 2>/dev/null || true
          fi

          # Create release branch from develop
          git checkout -b "${BRANCH}"

          # Update version in pyproject.toml
          NEW_VERSION="${VERSION}"
          sed -i "s/^version = .*/version = \"${NEW_VERSION}\"/" pyproject.toml

          # Generate changelog from git commits since last merge-back
          # This handles squash merge workflow correctly by finding the last
          # "chore: merge release" commit and showing only commits after that
          LAST_MERGE=$(git log --oneline --grep="^chore: merge release" -1 --format="%H" 2>/dev/null || echo "")
          if [ -z "$LAST_MERGE" ]; then
            # Fallback to tag-based range if no merge-back found
            LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
            if [ -z "$LAST_TAG" ]; then
              COMMIT_RANGE="HEAD"
            else
              COMMIT_RANGE="${LAST_TAG}..HEAD"
            fi
          else
            COMMIT_RANGE="${LAST_MERGE}..HEAD"
          fi

          # Get commits grouped by type (excluding merge-back commits themselves)
          FEATURES=$(git log $COMMIT_RANGE --pretty=format:"- %s" --grep="^feat" | grep -v "^- chore: merge release" || echo "")
          FIXES=$(git log $COMMIT_RANGE --pretty=format:"- %s" --grep="^fix" | grep -v "^- chore: merge release" || echo "")
          DOCS=$(git log $COMMIT_RANGE --pretty=format:"- %s" --grep="^docs" | grep -v "^- chore: merge release" || echo "")
          CHORES=$(git log $COMMIT_RANGE --pretty=format:"- %s" --grep="^chore" | grep -v "^- chore: merge release" || echo "")
          CI=$(git log $COMMIT_RANGE --pretty=format:"- %s" --grep="^ci" | grep -v "^- chore: merge release" || echo "")

          # Create new changelog entry
          TODAY=$(date +%Y-%m-%d)
          NEW_ENTRY="## [${VERSION}] - ${TODAY}"

          if [ -n "$FEATURES" ]; then
            NEW_ENTRY="${NEW_ENTRY}\n\n### Added\n${FEATURES}"
          fi
          if [ -n "$FIXES" ]; then
            NEW_ENTRY="${NEW_ENTRY}\n\n### Fixed\n${FIXES}"
          fi
          if [ -n "$DOCS" ]; then
            NEW_ENTRY="${NEW_ENTRY}\n\n### Documentation\n${DOCS}"
          fi
          if [ -n "$CI" ]; then
            NEW_ENTRY="${NEW_ENTRY}\n\n### CI/CD\n${CI}"
          fi
          if [ -n "$CHORES" ]; then
            NEW_ENTRY="${NEW_ENTRY}\n\n### Changed\n${CHORES}"
          fi

          # Replace [Unreleased] content with new version section
          # Keep [Unreleased] header but empty it, add new version section below
          awk -v entry="$NEW_ENTRY" '
            /^## \[Unreleased\]/ {
              print "## [Unreleased]"
              print ""
              print entry
              print ""
              # Skip until next version section
              in_unreleased=1
              next
            }
            in_unreleased && /^## \[/ {
              in_unreleased=0
            }
            !in_unreleased {
              print
            }
          ' CHANGELOG.md > CHANGELOG.md.tmp && mv CHANGELOG.md.tmp CHANGELOG.md

          # Manually commit the changes
          git add -A
          git commit -m "chore(release): ${VERSION}"

          # Push the release branch
          git push origin "${BRANCH}"

          echo "âœ… Created release branch: ${BRANCH}"

      - name: Create Pull Request
        if: steps.version.outputs.release_needed == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          VERSION=${{ steps.version.outputs.next_version }}
          BRANCH="release/${VERSION}"

          # Checkout release branch to access the updated CHANGELOG
          git checkout "${BRANCH}"

          # Extract changelog for this version using sed
          CHANGELOG_SECTION=$(sed -n "/^## \\[${VERSION}\\]/,/^## \\[/p" CHANGELOG.md | sed '$d' || echo "See CHANGELOG.md for details")

          # Create PR from release branch to main
          PR_URL=$(gh pr create \
            --title "chore(release): ${VERSION}" \
            --body "## ðŸš€ Release ${VERSION}

          This PR was automatically created by the **Create Release** workflow.

          ### ðŸ“‹ Changes in this release

          ${CHANGELOG_SECTION}

          ### âœ… Checklist before merging

          - [ ] Review the version bump (currently: **${VERSION}**)
          - [ ] Review the CHANGELOG.md updates
          - [ ] Verify all tests pass
          - [ ] Confirm this is the right time to release

          ### ðŸ”„ What happens after merge

          Once merged to \`main\`, the **Finalize Release** workflow will automatically:
          1. Create a git tag: \`v${VERSION}\`
          2. Create a GitHub release with release notes
          3. Build and attach the macOS binary
          4. Merge the release back to \`develop\` to keep branches in sync

          ---
          **Triggered by:** @${{ github.actor }}
          **Release type:** ${{ github.event.inputs.release-type }}" \
            --base main \
            --head "${BRANCH}")

          # Extract PR number and add label
          PR_NUMBER=$(echo "$PR_URL" | grep -oE '[0-9]+$')
          gh pr edit "$PR_NUMBER" \
            --add-label "release" 2>/dev/null || echo "â„¹ï¸  Note: 'release' label not found (skipped)"

          echo "âœ… Pull request created: release/${VERSION} â†’ main"
          echo "âœ… PR title set to: chore(release): ${VERSION}"
          echo "âœ… Repository squash merge enabled - commit will trigger finalize workflow"

      - name: Trigger CI checks
        if: steps.version.outputs.release_needed == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          VERSION=${{ steps.version.outputs.next_version }}
          BRANCH="release/${VERSION}"

          # Push an empty commit to trigger CI on the release branch
          # (GitHub doesn't auto-trigger workflows on bot-created PRs)
          # CI workflow now listens to push events on release/* branches
          git checkout "${BRANCH}"
          git commit --allow-empty -m "ci: trigger CI checks"
          git push origin "${BRANCH}"

          echo "âœ… CI checks triggered on release PR"

      - name: Summary
        if: steps.version.outputs.release_needed == 'true'
        run: |
          echo "## âœ… Release PR Created" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Version:** ${{ steps.version.outputs.next_version }}" >> $GITHUB_STEP_SUMMARY
          echo "**Branch:** release/${{ steps.version.outputs.next_version }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "ðŸ‘‰ Review and merge the PR to complete the release" >> $GITHUB_STEP_SUMMARY

      - name: No release needed
        if: steps.version.outputs.release_needed == 'false'
        run: |
          echo "## â„¹ï¸ No Release Needed" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "No relevant commits found since the last release." >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Make sure your commits follow the [Conventional Commits](https://www.conventionalcommits.org/) format:" >> $GITHUB_STEP_SUMMARY
          echo "- \`feat:\` for new features (minor version bump)" >> $GITHUB_STEP_SUMMARY
          echo "- \`fix:\` for bug fixes (patch version bump)" >> $GITHUB_STEP_SUMMARY
          echo "- \`BREAKING CHANGE:\` or \`!\` for breaking changes (major version bump)" >> $GITHUB_STEP_SUMMARY
          exit 1
